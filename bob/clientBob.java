import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.math.BigInteger;
import java.net.*;
import java.security.*;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.RSAPublicKeySpec;
import java.util.Base64;
import java.util.Random;
import java.util.Scanner;

public class clientBob {
    private static final String localHost = "127.0.0.1";
    private static BigInteger modulus;
    private static BigInteger exponent;


    public static void main(String[] args) {
	    try{
            clientBob rsaObj = new clientBob();
            Random rand = new Random();
            InetAddress address= InetAddress.getByName(localHost);
            DatagramSocket datagramSocket = new DatagramSocket();
            Scanner scanner = new Scanner(System.in);
            String echoString;
            RC4 rc4 = new RC4();
            GFG gfg = new GFG();

            //send username to server
            System.out.println("Client is connecting...");
            System.out.print("Please Enter Your Username: ");
            String username = scanner.nextLine();
            byte[] buffer = username.getBytes();
            DatagramPacket packet = new DatagramPacket(buffer, buffer.length, address, 5000);
            datagramSocket.send(packet);

            //Receive public key from server
            byte[] pkBfr = new byte[3000];
            packet = new DatagramPacket(pkBfr, pkBfr.length);
            datagramSocket.receive(packet);

            String pubKey = new String(pkBfr, 0, packet.getLength());
            int comaIdx = pubKey.indexOf(',');
            modulus = new BigInteger(pubKey.substring(0, comaIdx));
            exponent = new BigInteger(pubKey.substring(comaIdx+1));
            System.out.println("Public key received");
            System.out.println("Modulus: " + new String(pkBfr, 0, 20) + "...");
            System.out.println("Exponent: " + exponent);
            System.out.println("--------------------");

            //send k to server
            System.out.println("Random selecting K from public key...");
            int rand_int1 = rand.nextInt(10);
            int rand_int2 = rand.nextInt(10) + 20;
            String kStr = modulus.toString().substring(rand_int1, rand_int2);
            System.out.println("K: " + kStr);
            System.out.println("Length: " + kStr.length());
            byte[] kBytes = rsaObj.encryptData(kStr);
            byte[] encodedK = Base64.getEncoder().encode(kBytes);
            System.out.println("After RSA encryption: " + new String(encodedK, 0, 15) + "...");

            System.out.println("Sending encrypted K to Alice...");

            DatagramPacket packetK = new DatagramPacket(kBytes, kBytes.length, address, 5000);
            datagramSocket.send(packetK);
            System.out.println("Done!");
            System.out.println("--------------------");

            //Get password
            System.out.print("Enter Your Password: ");
            String password = scanner.nextLine();
            String UP = username + password;

            //Encrypt UserName and Password by using RC4
            String encryStr = rc4.encryRC4String(UP, kStr,"UTF-8");
            System.out.println("Encrypted U||P: " + encryStr);
            System.out.println("Waiting for verifying...");
            byte[] byteUP = encryStr.getBytes();
            DatagramPacket packetUP = new DatagramPacket(byteUP, byteUP.length, address, 5000);
            datagramSocket.send(packetUP);

            //Waiting for verifying
            byte[] bfrStatus = new byte[100];
            DatagramPacket packetStatus = new DatagramPacket(bfrStatus, bfrStatus.length);
            datagramSocket.receive(packetStatus);
            String checkStatus = new String(bfrStatus,0,packetStatus.getLength());
            if(checkStatus.equalsIgnoreCase("failed!")){
                System.out.println("Error: Invalid Login!");
                System.exit(-1);
            }else{
                System.out.println("--------------------");
                System.out.println("Login SuccessFul!");
                System.out.println("Connected to Alice");
                System.out.println(checkStatus);
                System.out.println("--------------------");
            }

            //Generate session key
            System.out.println("HashCode Generated by SHA-1 for ssk: ");
            String s1 = kStr + password;
            String ssk = gfg.encryptThisString(s1);
            System.out.println("SSK (Plaintext): " + s1);
            System.out.println("SSK (CipherText): " + ssk);
            System.out.println("--------------------");


            String msg = new String();
            String cipherRC4Str;
            do{
                System.out.print("Enter your message: ");
                echoString = scanner.nextLine();
                if(echoString.equalsIgnoreCase("exit")){
                    System.out.println("You has disconnected!");
                    System.out.println("Shutting Down the Program...");
                    String quitStr = "exit";
                    byte[] buffer5 = quitStr.getBytes();
                    DatagramPacket packet2 = new DatagramPacket(buffer5, buffer5.length, address, 5000);
                    datagramSocket.send(packet2);
                    System.exit(-1);
                }

                //Integrity check h = H(ssk||m||ssk)
                String hashStr = ssk + echoString + ssk;
                String h = gfg.encryptThisString(hashStr);

                //C = SKEssk(m||h)
                String c = echoString + h;

                System.out.println("Plaintext: " + c);
                String encryRC4Str = rc4.encryRC4String(c, ssk,"UTF-8");
                System.out.println("CipherText: " + encryRC4Str.substring(0,20) + "...");
                byte[] encryBuffer = encryRC4Str.getBytes();
                System.out.println("--------------------");

                //Send msg to Alice
                DatagramPacket packet2 = new DatagramPacket(encryBuffer, encryBuffer.length, address, 5000);
                datagramSocket.send(packet2);

                //Receive msg from Alice
                byte[] buffer2 = new byte[200];
                packet = new DatagramPacket(buffer2, buffer2.length);
                datagramSocket.receive(packet);

                cipherRC4Str = new String(buffer2, 0, packet.getLength());
                if(cipherRC4Str.equalsIgnoreCase("exit")){
                    System.out.println("Alice has disconnected!");
                    System.out.println("Shutting Down the Program...");
                    System.exit(-1);
                }
                System.out.println("Alice sent: ");
                System.out.println("CipherText: " + cipherRC4Str.substring(0, 20) + "...");
                String plaintRC4Str = rc4.decryRC4(cipherRC4Str, ssk, "UTF-8");
                System.out.println("h:  " + plaintRC4Str.substring(plaintRC4Str.length()-40));

                //Get message
                msg = plaintRC4Str.substring(0, plaintRC4Str.length()-40);

                //computes h^ = H(ssk||m||ssk) and checks if h = h^
                String hCheckStr = ssk + msg + ssk;
                String hCheck = gfg.encryptThisString(hCheckStr);
                System.out.println("h': " + hCheck);
                System.out.println("Authenticate Successfully");
                System.out.println("");
                if(hCheck.equals(plaintRC4Str.substring(plaintRC4Str.length()-40))){
                    System.out.println("Message: " + msg);
                    System.out.println("--------------------");
                }else{
                    String errorStr = "Communication Error!";
                    byte[] bufferErr = errorStr.getBytes();
                    packet2 = new DatagramPacket(bufferErr, bufferErr.length, address, 5000);
                    datagramSocket.send(packet2);
                }


            }while(true);


        } catch(SocketTimeoutException e){
            System.out.println("The socket timed out");
        } catch(IOException e){
            System.out.println("Client error: " + e.getMessage());
        }
    }

    private byte[] encryptData(String data) throws IOException{
        byte [] dataToEncrypt = data.getBytes();
        byte [] encryptedData = null;
        try{
            RSAPublicKeySpec rsaPublicKeySpec = new RSAPublicKeySpec(modulus, exponent);
            KeyFactory factory = KeyFactory.getInstance("RSA");
            PublicKey publicKey = factory.generatePublic(rsaPublicKeySpec);

            Cipher cipher = Cipher.getInstance("RSA");
            cipher.init(Cipher.ENCRYPT_MODE, publicKey);
            encryptedData = cipher.doFinal(dataToEncrypt);
            //System.out.println("CipherText: " + encryptedData);

        } catch (NoSuchPaddingException e) {
            e.printStackTrace();
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (InvalidKeyException e) {
            e.printStackTrace();
        } catch (BadPaddingException e) {
            e.printStackTrace();
        } catch (IllegalBlockSizeException e) {
            e.printStackTrace();
        } catch (InvalidKeySpecException e) {
            e.printStackTrace();
        }

        return encryptedData;
    }
}

class RC4 {

    public static String encryRC4String(String data, String key, String chartSet) throws UnsupportedEncodingException {
        if (data == null || key == null) {
            return null;
        }
        return bytesToHex(encryRC4Byte(data, key, chartSet));
    }


    public static byte[] encryRC4Byte(String data, String key, String chartSet) throws UnsupportedEncodingException {
        if (data == null || key == null) {
            return null;
        }
        if (chartSet == null || chartSet.isEmpty()) {
            byte bData[] = data.getBytes();
            return RC4Base(bData, key);
        } else {
            byte bData[] = data.getBytes(chartSet);
            return RC4Base(bData, key);
        }
    }


    public static String decryRC4(String data, String key, String chartSet) throws UnsupportedEncodingException {
        if (data == null || key == null) {
            return null;
        }
        return new String(RC4Base(hexToByte(data), key), chartSet);
    }


    private static byte[] initKey(String aKey) {
        byte[] bkey = aKey.getBytes();
        byte state[] = new byte[256];

        for (int i = 0; i < 256; i++) {
            state[i] = (byte) i;
        }
        int index1 = 0;
        int index2 = 0;
        if (bkey.length == 0) {
            return null;
        }
        for (int i = 0; i < 256; i++) {
            index2 = ((bkey[index1] & 0xff) + (state[i] & 0xff) + index2) & 0xff;
            byte tmp = state[i];
            state[i] = state[index2];
            state[index2] = tmp;
            index1 = (index1 + 1) % bkey.length;
        }
        return state;
    }


    public static String bytesToHex(byte[] bytes) {
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < bytes.length; i++) {
            String hex = Integer.toHexString(bytes[i] & 0xFF);
            if (hex.length() < 2) {
                sb.append(0);
            }
            sb.append(hex);
        }
        return sb.toString();
    }


    public static byte[] hexToByte(String inHex) {
        int hexlen = inHex.length();
        byte[] result;
        if (hexlen % 2 == 1) {
            hexlen++;
            result = new byte[(hexlen / 2)];
            inHex = "0" + inHex;
        } else {
            result = new byte[(hexlen / 2)];
        }
        int j = 0;
        for (int i = 0; i < hexlen; i += 2) {
            result[j] = (byte) Integer.parseInt(inHex.substring(i, i + 2), 16);
            j++;
        }
        return result;
    }


    private static byte[] RC4Base(byte[] input, String mKkey) {
        int x = 0;
        int y = 0;
        byte key[] = initKey(mKkey);
        int xorIndex;
        byte[] result = new byte[input.length];
        for (int i = 0; i < input.length; i++) {
            x = (x + 1) & 0xff;
            y = ((key[x] & 0xff) + y) & 0xff;
            byte tmp = key[x];
            key[x] = key[y];
            key[y] = tmp;
            xorIndex = ((key[x] & 0xff) + (key[y] & 0xff)) & 0xff;
            result[i] = (byte) (input[i] ^ key[xorIndex]);
        }
        return result;
    }
}

class GFG {
    public static String encryptThisString(String input) {
        try {
            // getInstance() method is called with algorithm SHA-1
            MessageDigest md = MessageDigest.getInstance("SHA-1");

            // digest() method is called
            // to calculate message digest of the input string
            // returned as array of byte
            byte[] messageDigest = md.digest(input.getBytes());

            // Convert byte array into signum representation
            BigInteger no = new BigInteger(1, messageDigest);

            // Convert message digest into hex value
            String hashtext = no.toString(16);

            // Add preceding 0s to make it 32 bit
            while (hashtext.length() < 32) {
                hashtext = "0" + hashtext;
            }

            // return the HashText
            return hashtext;
        }

        // For specifying wrong message digest algorithms
        catch (NoSuchAlgorithmException e) {
            throw new RuntimeException(e);
        }
    }
}
